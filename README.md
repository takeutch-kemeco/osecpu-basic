## OsecpuBasic version 0.0.3

OsecpuBasic は古典的な BASIC 言語のコンパイラーです。

osecpu-aska（マクロアセンブラー）によってコンパイルできるソースを出力します。

ライセンスはflex/bisonの義理を感じるので GPL2 です。



***
### 重要:

commit: 7be4b1d7ca3b21c92c20340be307eb1c4f07d99e 以降から現状までは
ソースコードの多くが壊れてます。
以下の仕様に書いてあることの多くは正常動作できないはずです。

現在の osecpu-basic が吐くアセンブラコードは osecpu067d 以上用です。

osecpu067d 未満のバージョンでは正常動作しません。



***

ビルド方法:

・ビルドには autoconf, automake, libtool が必要です。また、flex, bison も必要です。そして gcc, libc も当然必要です。

    ./autogen.sh --prefix=/usr
    make

これで src/ 以下に osecpubasic というバイナリができます。



***

使用方法:

・以下の方法で、BASICのソースファイルから、osecpu-aska のアセンブラコードへ変換できます。

    ./osecpubasic BASICのソースファイル.bas

これで、同名で拡張子が.askのファイルとして、カレントディレクトリ内に出力されます。
また、明示的に出力ファイル名を指定したい場合は

    ./osecpubasic BASICのソースファイル.bas 出力ファイル名.ask

とすることも可能です。
（ファイル名にパス名を含めても動作します）

***

現状できること:

***

スカラーおよび配列の宣言

・変数は宣言しないと使えません。

・配列は２次元配列まで使えます。

・添字でxを指定した場合は、確保される配列は 0 ～ x-1 までの x 個です。（c言語に近いです。一般的なBASICとは異なるかもしれません）

・dimを宣言の意味で使います。スカラー変数でも dim で宣言します。

    dim a
    dim b(10)
    dim c(10, 20)



***

変数への代入、および参照

・（重要！）代入は := で行います。（= ではありません。= は比較専用です）

・数は全て固定小数点型で扱われます。（符号1bit、整数15bit, 小数16bit）

    dim a
    a := 10

    dim b(100)
    b(a) := -3.14

    dim c(100,100)
    c(a, a) := 123.456
 


***

四則演算、符号付き剰余算、冪乗、論理演算、三角関数(sin,cosのみ)、演算の括弧によるくくり

・演算子の優先順位は * / mod ^ の方が + - よりも優先されます。

（従って以下の例では 1 + 2 - (3 * 4 / 5 mod 6 ^ 7)の順番で計算されます）

・また、論理演算は * / mod ^ よりも優先されますが、これについてはたまたまです。

（正式なBASIC言語の仕様では、優先順位が異なるかもしれません。
現状は仕様はあまり調べずに適当に作ってる段階なので、そのうち変わる可能性もあります）

・冪乗は a ^ b について、bが負、かつ、aが小数を含む場合は、結果を複素数で返すべきですが、複素数はサポートできていないので、変な値が返ります。注意。

・（というか冪乗がバグだらけなので誰かバグとってください）

    1 + 2 - 3 * 4 / 5 mod 6 ^ 7
    not (1 and 2 or 3 xor 4)
    x * (cos 3.14) + y * (sin -3.14)

これが期待通りに動きます。（願望）

    r := (x^2 + y^2 + z^2) ^ (1/2)



***

条件分岐

・複数行にわたる分岐は書けないっぽいです。

    dim a
    a := 0

    if a <= 10 then a := a + 1;
    if a = 0 then a := 1; else a := 0;
    if a = -1 then goto *E

    *E



***

繰り返し

    dim i
    for i := 1 to 10 step 1
        print i
        gosub *F
    next

    *F
    print 1
    return



***

ラベル

・ラベルは行の先頭でなければなりません。（インデントして書くことはできません）

    *L
    *label
    *end



***

ラベルへの goto

    let a
    a := 0

    *L
    a := a + 1
    goto *L



***

ラベルへの gosub, return

・gosub の中でさらに gosub しても、正常に return できます。

    gosub *X
    print 4

    goto *END

    *X
    print 1
    gosub *Y
    print 3
    return

    *Y
    print 2
    return

    *END



***

条件分岐 goto, gosub

    on a = 1 goto *L
    on a < 1 gosub *E



***

ユーザー関数定義

・一行関数、及び、複数行関数を定義できます。

・関数へ引数として渡した値は、ローカル変数となります。

・ローカル変数なので再帰的な呼び出しも可能です。

・関数に渡せる引数の数には制限はありません。

・現時点では配列全体を引数として渡すことはできません。（引数はスカラーのみしか渡せません）

・複数行関数の場合の戻り値は、関数名と同名のローカル変数へ代入した値が、戻り値となります。

    def f(x, y) := x ^ y
    
    function f(x, y)
        dim z
        z := x ^ y
        print z
        f := z
    end function



***

文字の扱いに関しては何も作ってません。

現状では文字は未サポートです。



